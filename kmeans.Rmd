---
title: "kmeans"
output: html_document
---
```{r, setup, include=FALSE}
knitr::opts_chunk$set(
  eval=FALSE, warning=FALSE, error=FALSE, message=FALSE
)
```

*The output of most of the R chunks isn't included in the HTML version of the file to keep it to a more reasonable file size.  You can run the code in R to see the output.*

This is an [R Markdown](https://rmarkdown.rstudio.com/) document. Follow the link to learn more about R Markdown and the notebook format used during the workshop.

# Setup

```{r, eval=TRUE}
library(dplyr)
library(readr)
library(tidyverse)
library(factoextra)
library(vip)
library(reshape2)
library(rattle) #wine data
```

# Data

We will be using two data sets throughout this workshop 

  + [Cereal data](https://www.kaggle.com/crawford/80-cereals) to demonstrate concepts 
  + [Wine data](https://cran.r-project.org/web/packages/rattle.data/rattle.data.pdf) to practice concepts 

```{r}
# cereal data
cereal <- read_csv("Cereals.csv")
```

What's in the data: 

```{r}
cereal
wine
```

## Variables 

k-means clustering requires complete cases

```{r}
#find cases with missing values 
cereal[!complete.cases(cereal),]
```

### Exercise

Does the wine data contain missing values? 

```{r}
```

## Standardize 

We are working with incommensurate units. This requires us to first standardize variables. Variables are often scaled to have mean 0 and variance 1. 

```{r}
scores <- cereal %>% select(4:6,8) %>% scale() 
str(cereal)
scores <- as.data.frame(scores)
```

### Exercise 

Make sure the wine data is in the data frame format. Select only the columns for alcohol, malic, ash, alcalinity, magnesium, and phenols. 

```{r}
```

# kmeans

Now that we've finished data pre-processing, we can find various cluster solutions. First we select a ballpark number of clusters (e.g. 2-6). 

```{r}
k2 <- kmeans(scores, centers = 2, nstart = 25)
str(k2)

k3 <- kmeans(scores, centers = 3, nstart = 25)
k4 <- kmeans(scores, centers = 4, nstart = 25)
k5 <- kmeans(scores, centers = 5, nstart = 25)
k6 <- kmeans(scores, centers = 6, nstart = 25)


# plots to compare
p1 <- fviz_cluster(k2, geom = "point", data = scores) + ggtitle("k = 2")
p2 <- fviz_cluster(k3, geom = "point",  data = scores) + ggtitle("k = 3")
p3 <- fviz_cluster(k4, geom = "point",  data = scores) + ggtitle("k = 4")
p4 <- fviz_cluster(k5, geom = "point",  data = scores) + ggtitle("k = 5")
p5 <- fviz_cluster(k6, geom = "point",  data = scores) + ggtitle("k = 6")


grid.arrange(p1, p2, p3, p4, nrow = 2)
```

# Number of Clusters

We can use silhouette statistic and plots to help us pick the cluster solution with the largest overall width. To learn more about [silhouettes](https://www.sciencedirect.com/science/article/pii/0377042787901257?via%3Dihub). Essentially, this measure quantifies how much better the assigned cluster is to the next best one. The value ranges from 0 to 1. 

```{r, dpi=600}
set.seed(404)
# function to compute total within-cluster sum of square 
wss <- function(k) {
  kmeans(scores, k, nstart = 10 )$tot.withinss
}

# Compute and plot wss for k = 1 to k = 15
k.values <- 1:15

# extract wss for 2-15 clusters
wss_values <- map_dbl(k.values, wss)

plot(k.values, wss_values,
     type="b", pch = 19, frame = FALSE, 
     xlab="Number of clusters K",
     ylab="Total within-clusters sum of squares")

set.seed(404)
fviz_nbclust(scores, kmeans, method = "wss")
fviz_nbclust(scores, kmeans, method = "silhouette")
fviz_nbclust(scores, kmeans, method = "silhouette")$data #silhouette widths 
```

# Optimal Cluster Solution
```{r}
set.seed(505)  # assures that you get same starting values
final <- kmeans(scores, 3, nstart = 25)
print(final)

c <- fviz_cluster(final, data = scores)
c

#cluster centers 
scores %>%
  mutate(Cluster = final$cluster) %>%
  group_by(Cluster) %>%
  summarise_all("mean")
```


# Bonus: Data Visulation with Boxplots 

```{r, fig.width=6, fig.height=6}
scores$cluster <- final$cluster
plotdf.m = melt(scores[,c(1:5)], id.var="cluster")  # transform data for plot
plotdf.m = plotdf.m[order(plotdf.m$variable, plotdf.m$cluster),]
```

```{r, fig.width=6, fig.height=6, dpi=600}
ggplot(data=plotdf.m, aes(x=as.factor(cluster), y=value)) + 
  geom_boxplot(aes(fill=as.factor(variable))) +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
        panel.background = element_blank(), axis.line = element_line(colour = "black")) +
  theme(legend.position="top") +
  labs(y="Scores", x="Cluster") + 
  labs(fill=NULL) 
```


